#!/bin/bash
#
# ARG_HELP([Sets up 2-tier PKI. With (1) Root and (2) Issuing certificates.])
# ARG_POSITIONAL_SINGLE([ca],[CA name])
# ARG_OPTIONAL_SINGLE([ca-id],[i],[short ID appended to CA name],[A1])
# ARG_OPTIONAL_SINGLE([domain-name],[d],[Two-segment domain name to be embedded in the certificates],[ideant.pl])
# ARG_OPTIONAL_SINGLE([org-name],[o],[Organization name to be embedded in the certificates],[Absolute Trust])
# ARG_OPTIONAL_SINGLE([org-unit-name],[u],[Organizational unit name to be embedded in the certificates],[Certificate Authority])
# ARG_OPTIONAL_SINGLE([yubi-slot],[s],[Yubi slot to put Root certificate],[9C])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='hidous'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_ca_id="A1"
_arg_domain_name="ideant.pl"
_arg_org_name="Absolute Trust"
_arg_org_unit_name="Certificate Authority"
_arg_yubi_slot="9C"


print_help()
{
	printf '%s\n' "Sets up 2-tier PKI. With (1) Root and (2) Issuing certificates."
	printf 'Usage: %s [-h|--help] [-i|--ca-id <arg>] [-d|--domain-name <arg>] [-o|--org-name <arg>] [-u|--org-unit-name <arg>] [-s|--yubi-slot <arg>] <ca>\n' "$0"
	printf '\t%s\n' "<ca>: CA name"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-i, --ca-id: short ID appended to CA name (default: 'A1')"
	printf '\t%s\n' "-d, --domain-name: Two-segment domain name to be embedded in the certificates (default: 'ideant.pl')"
	printf '\t%s\n' "-o, --org-name: Organization name to be embedded in the certificates (default: 'Absolute Trust')"
	printf '\t%s\n' "-u, --org-unit-name: Organizational unit name to be embedded in the certificates (default: 'Certificate Authority')"
	printf '\t%s\n' "-s, --yubi-slot: Yubi slot to put Root certificate (default: '9C')"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-i|--ca-id)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_ca_id="$2"
				shift
				;;
			--ca-id=*)
				_arg_ca_id="${_key##--ca-id=}"
				;;
			-i*)
				_arg_ca_id="${_key##-i}"
				;;
			-d|--domain-name)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_domain_name="$2"
				shift
				;;
			--domain-name=*)
				_arg_domain_name="${_key##--domain-name=}"
				;;
			-d*)
				_arg_domain_name="${_key##-d}"
				;;
			-o|--org-name)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_org_name="$2"
				shift
				;;
			--org-name=*)
				_arg_org_name="${_key##--org-name=}"
				;;
			-o*)
				_arg_org_name="${_key##-o}"
				;;
			-u|--org-unit-name)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_org_unit_name="$2"
				shift
				;;
			--org-unit-name=*)
				_arg_org_unit_name="${_key##--org-unit-name=}"
				;;
			-u*)
				_arg_org_unit_name="${_key##-u}"
				;;
			-s|--yubi-slot)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_yubi_slot="$2"
				shift
				;;
			--yubi-slot=*)
				_arg_yubi_slot="${_key##--yubi-slot=}"
				;;
			-s*)
				_arg_yubi_slot="${_key##-s}"
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'ca'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_ca "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


#!/bin/bash

# Sets up 2-tier PKI. With (1) Root and (2) Issuing certificates.
# Uploads Root certificate to yubi slot 9C

set -uo pipefail
IFS=$'\n\t'

GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BOLD=$(tput bold)
NOBOLD=$(tput sgr0)
UNDERLINE="\e[4m"
NOUNDERLINE="\e[0m"

function setup-directory-strucutre() {
    printf "\n==>> Setting up the directory ${1}/${2}\n"
    mkdir -p "${1}/${2}"/private "${1}/${2}"/db
    chmod 700 "${1}/${2}"/private
	if [ ! -f "${1}/${2}/db/${2}".db ]; then
    	cp /dev/null "${1}/${2}/db/${2}".db
	fi
	if [ ! -f "${1}/${2}/db/${2}".crt.srl ]; then
    	echo 01 > "${1}/${2}/db/${2}".crt.srl
	fi
	if [ ! -f "${1}/${2}/db/${2}".crl.srl ]; then
    	echo 01 > "${1}/${2}/db/${2}".crl.srl
	fi
    openssl rand -out ${1}/${2}/${2}-key-pass -hex 50
}

function configure-file {
    if [ ! -f "${2}${3}" ]; then
		printf "\n==>> Configuring file ${1} onto ${2}/${3}.conf\n"
        sed \
        -e "s|{{ CA }}|$CA|g" \
        -e "s|{{ CA_ID }}|$CA_ID|g" \
        -e "s|{{ MY_ORG_NAME }}|$MY_ORG_NAME|g" \
        -e "s|{{ MY_ORG_UNIT_NAME }}|$MY_ORG_UNIT_NAME|g" \
        -e "s|{{ MY_0_DOMAIN_COMPONENT }}|$MY_0_DOMAIN_COMPONENT|g" \
        -e "s|{{ MY_1_DOMAIN_COMPONENT }}|$MY_1_DOMAIN_COMPONENT|g" \
        ${1} > ${2}/${3}.conf
    else
        echo "WARNING using existing configuration ${2}/${3}"
        echo "To re-generate the configuration please remove this file"
    fi
}

function request-certificate() {
    printf "\n==>> Building the signing request ${1}/${2}.csr\n"
    openssl req -new \
        -config ${1}/${2}.conf \
        -out ${1}/${2}.csr \
        -newkey ec -pkeyopt ec_paramgen_curve:secp384r1 \
        -keyout ${1}/${2}/private/${2}.key -passout file:${1}/${2}/${2}-key-pass \
        -pubkey -verbose
    openssl req -in ${1}/${2}.csr -noout -text
}

confirm() {
    # call with a prompt string or use a default
    read -r -p "${1:-Are you sure? [y/N]} " response
    case "${response}" in
        [yY][eE][sS]|[yY]) 
            true
            ;;
        *)
            false
            ;;
    esac
}

function show-crt-status() {
    printf "\n==>> File ${1}/${2}.crt:\n"
	if [ -z $(which step) ]; then
    	openssl x509 -in ${1}/${2}.crt -fingerprint -sha256 -noout | tr -d ':' | tr 'A-F' 'a-f'
		openssl x509 -in ${1}/${2}.crt -noout -subject -issuer -serial -dates    	
	else
		openssl x509 -in ${1}/${2}.crt -fingerprint -sha256 -noout | tr -d ':' | tr 'A-F' 'a-f'
		step certificate inspect ${1}/${2}.crt
	fi
}

function shred-file() {
    printf "\n==>> Shreding the file ${1}/${2} from disk\n"
    shred --remove ${1}/${2}
}

main() {

    CA=$_arg_ca
	if [[ -n "${_arg_ca_id}" ]]; then
		CA_ID="-${_arg_ca_id}"
	fi
    MY_ORG_NAME=$_arg_org_name
    MY_ORG_UNIT_NAME=$_arg_org_unit_name
    MY_1_DOMAIN_COMPONENT="${_arg_domain_name%.*}"
    MY_0_DOMAIN_COMPONENT="${_arg_domain_name##*.}"

	MY_ROOT_BASEFILENAME="${CA}-Root${CA_ID}"
	MY_ISSUING_BASEFILENAME="${CA}-Issuing${CA_ID}"
	MY_CA_BASEFOLDER="ca"

	printf "\n==> Time: $(date)\n"
	setup-directory-strucutre \
		"${MY_CA_BASEFOLDER}" \
		"${MY_ROOT_BASEFILENAME}"
    configure-file \
		"templates/root.conf" \
		"${MY_CA_BASEFOLDER}" \
		"${MY_ROOT_BASEFILENAME}"

	printf "\n==>> Getting the file ca/${1}.crt from yubi slot 9C\n"
	ykman piv \
		certificates export 9C "${MY_CA_BASEFOLDER}/${MY_ROOT_BASEFILENAME}".crt
	show-crt-status \
		"${MY_CA_BASEFOLDER}" \
		"${MY_ROOT_BASEFILENAME}"
	confirm "Do you want to contiue with ${MY_CA_BASEFOLDER}/${MY_ROOT_BASEFILENAME}? [y/N]" \
		|| exit 0

	setup-directory-strucutre \
		"${MY_CA_BASEFOLDER}" \
		"${MY_ISSUING_BASEFILENAME}"
    configure-file \
		"templates/issuing.conf" \
		"${MY_CA_BASEFOLDER}" \
		"${MY_ISSUING_BASEFILENAME}"

    request-certificate \
		"${MY_CA_BASEFOLDER}" \
		"${MY_ISSUING_BASEFILENAME}"

	confirm "Do you want to contiue signing ${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME}.csr request for Issuing certificate? [y/N]" \
		|| exit 0

    printf "\n==>> The ${CA}-Root signing the ${CA}-Issuing certificate\n"
    printf "\n${RED}** **${NC} ${BOLD}${UNDERLINE}Touch${NOUNDERLINE} yubi if needed${NOBOLD} ${RED}** **${NC}\n\n"
    OPENSSL_CONF=/usr/lib/x86_64-linux-gnu/engines-3/pkcs11.so \
        openssl x509 -req \
            -engine pkcs11 -CAkeyform engine -CAkey "pkcs11:id=%02;type=private" \
            -in "${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME}".csr \
			-extfile "${MY_CA_BASEFOLDER}/${MY_ROOT_BASEFILENAME}".conf -sha512 \
			-CA "${MY_CA_BASEFOLDER}/${MY_ROOT_BASEFILENAME}".crt \
            -out ${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME}.crt -batch \
			-days 1461 \
            -extensions issuing_ca_ext

    printf "\n==>> Packing the ${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME} certificate to pfx\n"    
    sed -i 'p' ${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME}/${MY_ISSUING_BASEFILENAME}-key-pass # Doubling the password, as per openssl -passin-passout requirements
    openssl pkcs12 -export \
		-inkey ${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME}/private/${MY_ISSUING_BASEFILENAME}.key \
		-in ${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME}.crt \
		-out ${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME}.pfx \
        -passin file:${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME}/${MY_ISSUING_BASEFILENAME}-key-pass \
        -passout file:${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME}/${MY_ISSUING_BASEFILENAME}-key-pass    
    sed -i -n '1p' ${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME}/${MY_ISSUING_BASEFILENAME}-key-pass # Removing the doubled line

    confirm "Do you want to leave ${MY_CA_BASEFOLDER}/${MY_ISSUING_BASEFILENAME}.csr? [y/N]" \
		|| shred-file \
			"${MY_CA_BASEFOLDER}" \
			"${MY_ISSUING_BASEFILENAME}".csr

    ykman piv info    
    show-crt-status \
		"${MY_CA_BASEFOLDER}" \
		"${MY_ISSUING_BASEFILENAME}"
	printf "\n==> Time: $(date)\n"}
}

main "$@"


# ] <-- needed because of Argbash
